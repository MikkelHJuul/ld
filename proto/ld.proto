syntax = "proto3";

option go_package = "github.com/MikkelHJuul/ld/service";

package service;

//the service `ld` is a database. As you can see it does one thing. CRUD!
service ld {
    rpc Create(KeyValue) returns (CreateResponse);
    rpc CreateMany(stream KeyValue) returns (stream CreateResponse);

    rpc Read(Key) returns (KeyValue);
    rpc ReadMany(stream Key) returns (stream KeyValue);
    rpc ReadRange(KeyRange) returns (stream KeyValue);

    rpc Update(KeyValue) returns (KeyValue);
    rpc UpdateMany(stream KeyValue) returns (stream KeyValue);

    rpc Delete(Key) returns (KeyValue);
    rpc DeleteMany(stream Key) returns (stream KeyValue);
    rpc DeleteRange(KeyRange) returns (stream KeyValue);

    //possibly add signatures DoMany(KeyList) returns (stream KeyValue) because there are transaction-benefits to that.
}

// A response, true for Errors
// empty response for no error
message CreateResponse {
    bool error = 1;
}

//The Key when querying directly for it
message Key {
    string key = 1;  // [(validate.rules).string { pattern: "(?i)^[0-9a-zA-Z_-.~]+$", max_len: 64 }];  // https://tools.ietf.org/html/rfc3986//section-2.3
}

//A key-range is the only possibility of querying the data outside of a direct Key.
//The logical operator between using prefix, pattern and from-to together is AND.
//OR is not implemented as it can be done using more than one request
//Empty KeyRange implies a full database stream
message KeyRange {
    //A key-prefix to search within.
    //when using prefix along-side pattern and/or from-to they should both match.
    // ie. a prefix "jo" could be used to speed up query speed of
    //     pattern "john*" or from: "john1" to: "john6"
    //the server will not try to guess a prefix from the pattern or from-to parameters
    string prefix = 1;

    // RE2 style regex, see: https://github.com/google/re2/wiki/Syntax
    string pattern = 2;

    // both inclusive
    // required for discrete systems with discrete queries
    //  -- since you cannot reference a value outside of the last/first,
    //     and would then not be able to query the last/first record.
    string from = 3;
    string to = 4;
}

message KeyValue {
    string key = 1;
    //You can easily replace this with google's Any if your want to
    //Or replace with your own message-type
    //
    //fx you have some software that simply expose data from a datasource
    //Your software exposes it as proto. This will be your datasource.
    // rewrite this .proto-file on the client side
    // add `import "your_messages_file.proto"`
    // replace the bytes of this with the type/format you wish to save
    // this works because string, bytes and nested messages are encoded the same:
    //   read https://developers.google.com/protocol-buffers/docs/encoding#strings
    //   and https://developers.google.com/protocol-buffers/docs/encoding#embedded
    bytes value = 2;
}
