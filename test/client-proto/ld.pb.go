// Code generated by protoc-gen-go. DO NOT EDIT.
// source: test/client-proto/ld.proto

package client_proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type KeyRange struct {
	Pattern              string   `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	From                 string   `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   string   `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyRange) Reset()         { *m = KeyRange{} }
func (m *KeyRange) String() string { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()    {}
func (*KeyRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_77c537a85023559e, []int{0}
}

func (m *KeyRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyRange.Unmarshal(m, b)
}
func (m *KeyRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyRange.Marshal(b, m, deterministic)
}
func (m *KeyRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRange.Merge(m, src)
}
func (m *KeyRange) XXX_Size() int {
	return xxx_messageInfo_KeyRange.Size(m)
}
func (m *KeyRange) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRange.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRange proto.InternalMessageInfo

func (m *KeyRange) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *KeyRange) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *KeyRange) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

type InsertResponse struct {
	OK                   bool     `protobuf:"varint,1,opt,name=OK,proto3" json:"OK,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertResponse) Reset()         { *m = InsertResponse{} }
func (m *InsertResponse) String() string { return proto.CompactTextString(m) }
func (*InsertResponse) ProtoMessage()    {}
func (*InsertResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77c537a85023559e, []int{1}
}

func (m *InsertResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InsertResponse.Unmarshal(m, b)
}
func (m *InsertResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InsertResponse.Marshal(b, m, deterministic)
}
func (m *InsertResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertResponse.Merge(m, src)
}
func (m *InsertResponse) XXX_Size() int {
	return xxx_messageInfo_InsertResponse.Size(m)
}
func (m *InsertResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InsertResponse proto.InternalMessageInfo

func (m *InsertResponse) GetOK() bool {
	if m != nil {
		return m.OK
	}
	return false
}

type Key struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_77c537a85023559e, []int{2}
}

func (m *Key) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key.Unmarshal(m, b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key.Marshal(b, m, deterministic)
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return xxx_messageInfo_Key.Size(m)
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

func (m *Key) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type KeyValue struct {
	Key                  *Key        `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                *YourObject `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_77c537a85023559e, []int{3}
}

func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyValue.Unmarshal(m, b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return xxx_messageInfo_KeyValue.Size(m)
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() *Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KeyValue) GetValue() *YourObject {
	if m != nil {
		return m.Value
	}
	return nil
}

type YourObject struct {
	John                 *John    `protobuf:"bytes,1,opt,name=john,proto3" json:"john,omitempty"`
	JohnsApprentice      *John    `protobuf:"bytes,2,opt,name=johnsApprentice,proto3" json:"johnsApprentice,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *YourObject) Reset()         { *m = YourObject{} }
func (m *YourObject) String() string { return proto.CompactTextString(m) }
func (*YourObject) ProtoMessage()    {}
func (*YourObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_77c537a85023559e, []int{4}
}

func (m *YourObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_YourObject.Unmarshal(m, b)
}
func (m *YourObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_YourObject.Marshal(b, m, deterministic)
}
func (m *YourObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YourObject.Merge(m, src)
}
func (m *YourObject) XXX_Size() int {
	return xxx_messageInfo_YourObject.Size(m)
}
func (m *YourObject) XXX_DiscardUnknown() {
	xxx_messageInfo_YourObject.DiscardUnknown(m)
}

var xxx_messageInfo_YourObject proto.InternalMessageInfo

func (m *YourObject) GetJohn() *John {
	if m != nil {
		return m.John
	}
	return nil
}

func (m *YourObject) GetJohnsApprentice() *John {
	if m != nil {
		return m.JohnsApprentice
	}
	return nil
}

type John struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Occupation           string   `protobuf:"bytes,2,opt,name=occupation,proto3" json:"occupation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *John) Reset()         { *m = John{} }
func (m *John) String() string { return proto.CompactTextString(m) }
func (*John) ProtoMessage()    {}
func (*John) Descriptor() ([]byte, []int) {
	return fileDescriptor_77c537a85023559e, []int{5}
}

func (m *John) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_John.Unmarshal(m, b)
}
func (m *John) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_John.Marshal(b, m, deterministic)
}
func (m *John) XXX_Merge(src proto.Message) {
	xxx_messageInfo_John.Merge(m, src)
}
func (m *John) XXX_Size() int {
	return xxx_messageInfo_John.Size(m)
}
func (m *John) XXX_DiscardUnknown() {
	xxx_messageInfo_John.DiscardUnknown(m)
}

var xxx_messageInfo_John proto.InternalMessageInfo

func (m *John) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *John) GetOccupation() string {
	if m != nil {
		return m.Occupation
	}
	return ""
}

func init() {
	proto.RegisterType((*KeyRange)(nil), "service.KeyRange")
	proto.RegisterType((*InsertResponse)(nil), "service.InsertResponse")
	proto.RegisterType((*Key)(nil), "service.Key")
	proto.RegisterType((*KeyValue)(nil), "service.KeyValue")
	proto.RegisterType((*YourObject)(nil), "service.YourObject")
	proto.RegisterType((*John)(nil), "service.John")
}

func init() { proto.RegisterFile("test/client-proto/ld.proto", fileDescriptor_77c537a85023559e) }

var fileDescriptor_77c537a85023559e = []byte{
	// 419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0x5f, 0x6f, 0xd3, 0x30,
	0x14, 0xc5, 0x95, 0xa4, 0xeb, 0xb6, 0x5b, 0x18, 0x70, 0x79, 0x58, 0xd4, 0x87, 0x69, 0xe4, 0xa9,
	0x13, 0x5a, 0x52, 0xca, 0x10, 0x12, 0xe2, 0x05, 0x84, 0xd0, 0x58, 0x34, 0x55, 0x8a, 0x04, 0x12,
	0xbc, 0xa5, 0xee, 0xa5, 0x49, 0xeb, 0xda, 0x51, 0xe2, 0x54, 0xca, 0xa7, 0xe1, 0xab, 0x22, 0x3b,
	0xe9, 0x7f, 0xa4, 0xd2, 0x27, 0x5f, 0x9f, 0xfb, 0x3b, 0xf6, 0xb1, 0xe3, 0x40, 0x57, 0x51, 0xa1,
	0x02, 0xc6, 0x53, 0x12, 0xea, 0x36, 0xcb, 0xa5, 0x92, 0x01, 0x1f, 0xfb, 0xa6, 0xc0, 0xd3, 0x82,
	0xf2, 0x45, 0xca, 0xc8, 0xbb, 0x87, 0xb3, 0x90, 0xaa, 0x28, 0x16, 0x13, 0x42, 0x17, 0x4e, 0xb3,
	0x58, 0x29, 0xca, 0x85, 0x6b, 0x5d, 0x5b, 0xbd, 0xf3, 0x68, 0x39, 0x45, 0x84, 0xd6, 0xef, 0x5c,
	0xce, 0x5d, 0xdb, 0xc8, 0xa6, 0xc6, 0x0b, 0xb0, 0x95, 0x74, 0x1d, 0xa3, 0xd8, 0x4a, 0x7a, 0xd7,
	0x70, 0xf1, 0x4d, 0x14, 0x94, 0xab, 0x88, 0x8a, 0x4c, 0x8a, 0x82, 0x34, 0x31, 0x0c, 0xcd, 0x52,
	0x67, 0x91, 0x3d, 0x0c, 0xbd, 0x4b, 0x70, 0x42, 0xaa, 0xf0, 0x39, 0x38, 0x33, 0xaa, 0x9a, 0x2d,
	0x74, 0xe9, 0x7d, 0x37, 0x21, 0x7e, 0xc4, 0xbc, 0x24, 0xbc, 0x5a, 0x77, 0x3b, 0x83, 0x27, 0x7e,
	0x93, 0xd3, 0xd7, 0x21, 0x75, 0x03, 0x6f, 0xe0, 0x64, 0xa1, 0x41, 0x93, 0xa5, 0x33, 0x78, 0xb9,
	0x22, 0x7e, 0xca, 0x32, 0x1f, 0x8e, 0xa6, 0xc4, 0x54, 0x54, 0x13, 0x5e, 0x02, 0xb0, 0x16, 0xf1,
	0x15, 0xb4, 0xa6, 0x32, 0x11, 0xcd, 0xca, 0x4f, 0x57, 0xbe, 0x07, 0x99, 0x88, 0xc8, 0xb4, 0xf0,
	0x3d, 0x3c, 0xd3, 0x63, 0xf1, 0x29, 0xcb, 0x72, 0x12, 0x2a, 0x65, 0xcb, 0x5d, 0x76, 0xe8, 0x5d,
	0xca, 0xfb, 0x00, 0x2d, 0xdd, 0xd0, 0xf7, 0x24, 0xe2, 0x39, 0x35, 0x67, 0x33, 0x35, 0x5e, 0x01,
	0x48, 0xc6, 0xca, 0x2c, 0x56, 0xa9, 0x14, 0xcd, 0x0d, 0x6e, 0x28, 0x83, 0x3f, 0x0e, 0xd8, 0x7c,
	0x8c, 0x3d, 0x38, 0xf9, 0x4a, 0x8a, 0x25, 0xb8, 0x75, 0xe6, 0xee, 0x8b, 0xcd, 0x59, 0x7d, 0x43,
	0x7d, 0x38, 0x37, 0xe4, 0x63, 0x2c, 0xaa, 0x83, 0x74, 0xcf, 0xea, 0x5b, 0x78, 0x07, 0x60, 0x1c,
	0xf5, 0x67, 0xde, 0x82, 0x8c, 0xf4, 0x0f, 0x5f, 0xdf, 0xc2, 0x1b, 0x68, 0x7f, 0x21, 0x4e, 0x8a,
	0x0e, 0x47, 0x7a, 0x03, 0x50, 0xa3, 0xff, 0x9f, 0xe9, 0x1d, 0x74, 0x6a, 0xcb, 0x71, 0xa1, 0xee,
	0xa0, 0x5d, 0xbf, 0x32, 0xdc, 0x6f, 0x77, 0x2f, 0x57, 0xd2, 0xce, 0x4b, 0xfc, 0x08, 0x50, 0x2b,
	0x26, 0xdf, 0x11, 0x4e, 0x1d, 0xf5, 0xf3, 0xed, 0xaf, 0xd7, 0x93, 0x54, 0x25, 0xe5, 0xc8, 0x67,
	0x72, 0x1e, 0x3c, 0xa6, 0xb3, 0x19, 0xf1, 0xfb, 0x87, 0xb2, 0xe4, 0x01, 0x1f, 0x07, 0x7b, 0x3f,
	0xd9, 0xa8, 0x6d, 0x86, 0xb7, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x0e, 0xa7, 0xaa, 0x4d, 0x80,
	0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// LdClient is the client API for Ld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LdClient interface {
	//// read
	Fetch(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeyValue, error)
	FetchMany(ctx context.Context, opts ...grpc.CallOption) (Ld_FetchManyClient, error)
	FetchRange(ctx context.Context, in *KeyRange, opts ...grpc.CallOption) (Ld_FetchRangeClient, error)
	//// Delete
	Delete(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeyValue, error)
	DeleteMany(ctx context.Context, opts ...grpc.CallOption) (Ld_DeleteManyClient, error)
	DeleteRange(ctx context.Context, in *KeyRange, opts ...grpc.CallOption) (Ld_DeleteRangeClient, error)
	//// Create
	Insert(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*InsertResponse, error)
	InsertMany(ctx context.Context, opts ...grpc.CallOption) (Ld_InsertManyClient, error)
}

type ldClient struct {
	cc grpc.ClientConnInterface
}

func NewLdClient(cc grpc.ClientConnInterface) LdClient {
	return &ldClient{cc}
}

func (c *ldClient) Fetch(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeyValue, error) {
	out := new(KeyValue)
	err := c.cc.Invoke(ctx, "/service.ld/Fetch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ldClient) FetchMany(ctx context.Context, opts ...grpc.CallOption) (Ld_FetchManyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Ld_serviceDesc.Streams[0], "/service.ld/FetchMany", opts...)
	if err != nil {
		return nil, err
	}
	x := &ldFetchManyClient{stream}
	return x, nil
}

type Ld_FetchManyClient interface {
	Send(*Key) error
	Recv() (*KeyValue, error)
	grpc.ClientStream
}

type ldFetchManyClient struct {
	grpc.ClientStream
}

func (x *ldFetchManyClient) Send(m *Key) error {
	return x.ClientStream.SendMsg(m)
}

func (x *ldFetchManyClient) Recv() (*KeyValue, error) {
	m := new(KeyValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ldClient) FetchRange(ctx context.Context, in *KeyRange, opts ...grpc.CallOption) (Ld_FetchRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Ld_serviceDesc.Streams[1], "/service.ld/FetchRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &ldFetchRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Ld_FetchRangeClient interface {
	Recv() (*KeyValue, error)
	grpc.ClientStream
}

type ldFetchRangeClient struct {
	grpc.ClientStream
}

func (x *ldFetchRangeClient) Recv() (*KeyValue, error) {
	m := new(KeyValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ldClient) Delete(ctx context.Context, in *Key, opts ...grpc.CallOption) (*KeyValue, error) {
	out := new(KeyValue)
	err := c.cc.Invoke(ctx, "/service.ld/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ldClient) DeleteMany(ctx context.Context, opts ...grpc.CallOption) (Ld_DeleteManyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Ld_serviceDesc.Streams[2], "/service.ld/DeleteMany", opts...)
	if err != nil {
		return nil, err
	}
	x := &ldDeleteManyClient{stream}
	return x, nil
}

type Ld_DeleteManyClient interface {
	Send(*Key) error
	Recv() (*KeyValue, error)
	grpc.ClientStream
}

type ldDeleteManyClient struct {
	grpc.ClientStream
}

func (x *ldDeleteManyClient) Send(m *Key) error {
	return x.ClientStream.SendMsg(m)
}

func (x *ldDeleteManyClient) Recv() (*KeyValue, error) {
	m := new(KeyValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ldClient) DeleteRange(ctx context.Context, in *KeyRange, opts ...grpc.CallOption) (Ld_DeleteRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Ld_serviceDesc.Streams[3], "/service.ld/DeleteRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &ldDeleteRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Ld_DeleteRangeClient interface {
	Recv() (*KeyValue, error)
	grpc.ClientStream
}

type ldDeleteRangeClient struct {
	grpc.ClientStream
}

func (x *ldDeleteRangeClient) Recv() (*KeyValue, error) {
	m := new(KeyValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ldClient) Insert(ctx context.Context, in *KeyValue, opts ...grpc.CallOption) (*InsertResponse, error) {
	out := new(InsertResponse)
	err := c.cc.Invoke(ctx, "/service.ld/Insert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ldClient) InsertMany(ctx context.Context, opts ...grpc.CallOption) (Ld_InsertManyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Ld_serviceDesc.Streams[4], "/service.ld/InsertMany", opts...)
	if err != nil {
		return nil, err
	}
	x := &ldInsertManyClient{stream}
	return x, nil
}

type Ld_InsertManyClient interface {
	Send(*KeyValue) error
	Recv() (*InsertResponse, error)
	grpc.ClientStream
}

type ldInsertManyClient struct {
	grpc.ClientStream
}

func (x *ldInsertManyClient) Send(m *KeyValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *ldInsertManyClient) Recv() (*InsertResponse, error) {
	m := new(InsertResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LdServer is the server API for Ld service.
type LdServer interface {
	//// read
	Fetch(context.Context, *Key) (*KeyValue, error)
	FetchMany(Ld_FetchManyServer) error
	FetchRange(*KeyRange, Ld_FetchRangeServer) error
	//// Delete
	Delete(context.Context, *Key) (*KeyValue, error)
	DeleteMany(Ld_DeleteManyServer) error
	DeleteRange(*KeyRange, Ld_DeleteRangeServer) error
	//// Create
	Insert(context.Context, *KeyValue) (*InsertResponse, error)
	InsertMany(Ld_InsertManyServer) error
}

// UnimplementedLdServer can be embedded to have forward compatible implementations.
type UnimplementedLdServer struct {
}

func (*UnimplementedLdServer) Fetch(ctx context.Context, req *Key) (*KeyValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fetch not implemented")
}
func (*UnimplementedLdServer) FetchMany(srv Ld_FetchManyServer) error {
	return status.Errorf(codes.Unimplemented, "method FetchMany not implemented")
}
func (*UnimplementedLdServer) FetchRange(req *KeyRange, srv Ld_FetchRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method FetchRange not implemented")
}
func (*UnimplementedLdServer) Delete(ctx context.Context, req *Key) (*KeyValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedLdServer) DeleteMany(srv Ld_DeleteManyServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteMany not implemented")
}
func (*UnimplementedLdServer) DeleteRange(req *KeyRange, srv Ld_DeleteRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteRange not implemented")
}
func (*UnimplementedLdServer) Insert(ctx context.Context, req *KeyValue) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (*UnimplementedLdServer) InsertMany(srv Ld_InsertManyServer) error {
	return status.Errorf(codes.Unimplemented, "method InsertMany not implemented")
}

func RegisterLdServer(s *grpc.Server, srv LdServer) {
	s.RegisterService(&_Ld_serviceDesc, srv)
}

func _Ld_Fetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LdServer).Fetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.ld/Fetch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LdServer).Fetch(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ld_FetchMany_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LdServer).FetchMany(&ldFetchManyServer{stream})
}

type Ld_FetchManyServer interface {
	Send(*KeyValue) error
	Recv() (*Key, error)
	grpc.ServerStream
}

type ldFetchManyServer struct {
	grpc.ServerStream
}

func (x *ldFetchManyServer) Send(m *KeyValue) error {
	return x.ServerStream.SendMsg(m)
}

func (x *ldFetchManyServer) Recv() (*Key, error) {
	m := new(Key)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Ld_FetchRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KeyRange)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LdServer).FetchRange(m, &ldFetchRangeServer{stream})
}

type Ld_FetchRangeServer interface {
	Send(*KeyValue) error
	grpc.ServerStream
}

type ldFetchRangeServer struct {
	grpc.ServerStream
}

func (x *ldFetchRangeServer) Send(m *KeyValue) error {
	return x.ServerStream.SendMsg(m)
}

func _Ld_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LdServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.ld/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LdServer).Delete(ctx, req.(*Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ld_DeleteMany_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LdServer).DeleteMany(&ldDeleteManyServer{stream})
}

type Ld_DeleteManyServer interface {
	Send(*KeyValue) error
	Recv() (*Key, error)
	grpc.ServerStream
}

type ldDeleteManyServer struct {
	grpc.ServerStream
}

func (x *ldDeleteManyServer) Send(m *KeyValue) error {
	return x.ServerStream.SendMsg(m)
}

func (x *ldDeleteManyServer) Recv() (*Key, error) {
	m := new(Key)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Ld_DeleteRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KeyRange)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LdServer).DeleteRange(m, &ldDeleteRangeServer{stream})
}

type Ld_DeleteRangeServer interface {
	Send(*KeyValue) error
	grpc.ServerStream
}

type ldDeleteRangeServer struct {
	grpc.ServerStream
}

func (x *ldDeleteRangeServer) Send(m *KeyValue) error {
	return x.ServerStream.SendMsg(m)
}

func _Ld_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LdServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.ld/Insert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LdServer).Insert(ctx, req.(*KeyValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ld_InsertMany_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LdServer).InsertMany(&ldInsertManyServer{stream})
}

type Ld_InsertManyServer interface {
	Send(*InsertResponse) error
	Recv() (*KeyValue, error)
	grpc.ServerStream
}

type ldInsertManyServer struct {
	grpc.ServerStream
}

func (x *ldInsertManyServer) Send(m *InsertResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *ldInsertManyServer) Recv() (*KeyValue, error) {
	m := new(KeyValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Ld_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service.ld",
	HandlerType: (*LdServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Fetch",
			Handler:    _Ld_Fetch_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Ld_Delete_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Ld_Insert_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchMany",
			Handler:       _Ld_FetchMany_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "FetchRange",
			Handler:       _Ld_FetchRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteMany",
			Handler:       _Ld_DeleteMany_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeleteRange",
			Handler:       _Ld_DeleteRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InsertMany",
			Handler:       _Ld_InsertMany_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "test/client-proto/ld.proto",
}
